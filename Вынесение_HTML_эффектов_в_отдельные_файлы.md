# Вынесение HTML эффектов в отдельные файлы + настройка элементов управления

## Цель
Организовать архитектуру, при которой каждый аудиоэффект реализуется как отдельная пара файлов (HTML + JS), а взаимодействие с элементами управления (кнопки, ползунки, переключатели и т.п.) стандартизировано через методы базового класса и его наследников.

## Архитектура

### 1. Структура файлов

```
AudioFX-main/
│
├── effects/
│   ├── DelayEffect.html
│   ├── DelayEffect.js
│   ├── DistortionEffect.html
│   ├── DistortionEffect.js
│   └── ... (другие эффекты)
│
├── core/
│   ├── AbstractEffectNode.js
│   └── ...
│
├── index.html
├── script.js
└── ...
```

### 2. AbstractEffectNode (core/AbstractEffectNode.js)

Назначение:  
Базовый класс для всех эффектов. Определяет стандартный интерфейс для интеграции с UI/DOM.

Методы, которые нужно реализовать:

- constructor(audioContext, domElement)
  - Принимает аудиоконтекст и ссылку на DOM-элемент (контейнер эффекта).
  - Сохраняет эти ссылки для дальнейшей работы.

- initUI()
  - Абстрактный/пустой метод.
  - В наследниках реализуется логика поиска элементов управления внутри domElement и навешивания обработчиков событий.

- setParam(paramName, value)
  - Универсальный метод для изменения параметров эффекта (например, вызывается из обработчиков событий).
  - В наследниках реализуется обработка конкретных параметров.

- getParam(paramName)
  - Получение текущего значения параметра (например, для синхронизации UI).

- destroy()
  - Метод для очистки: удаление обработчиков, дисконнект аудио-ноды и т.д.

Пример:
```js
export class AbstractEffectNode {
  constructor(audioContext, domElement) {
    this.audioContext = audioContext;
    this.domElement = domElement;
    this.initUI();
  }
  initUI() {}
  setParam(paramName, value) {}
  getParam(paramName) {}
  destroy() {}
}
```

### 3. Наследники (конкретные эффекты, например, DelayEffect.js)

Назначение:  
Реализуют аудиологику и интеграцию с UI для конкретного эффекта.

Методы:

- constructor(audioContext, domElement)
  - Вызывает super().
  - Создаёт аудио-ноды (например, DelayNode).
  - Сохраняет параметры.

- initUI()
  - Находит элементы управления внутри domElement (через class или data-атрибуты).
  - Навешивает обработчики событий, которые вызывают setParam.

- setParam(paramName, value)
  - Реализует изменение параметров аудио-ноды (например, delayTime, feedback и т.д.).

- getParam(paramName)
  - Возвращает текущее значение параметра.

- destroy()
  - Удаляет обработчики событий, дисконнектит аудио-ноды.

Пример:
```js
import { AbstractEffectNode } from '../core/AbstractEffectNode.js';

export class DelayEffect extends AbstractEffectNode {
  constructor(audioContext, domElement) {
    super(audioContext, domElement);
    ...
  }

  initUI() {
    this.delay_time = this.domElement.querySelector('[data-fx-delay_time]');
    this.delaySlider.addEventListener('input', (e) => {
      this.setParam('delayTime', parseFloat(e.target.value));
    });
  }

  setParam(paramName, value) {
    if (paramName === 'delayTime') {
      this.delayNode.delay.value = value;
    }
  }

  getParam(paramName) {
    if (paramName === 'delayTime') {
      return this.delayNode.delayTime.value;
    }
  }


}
```

### 4. HTML-файл эффекта (например, DelayEffect.html)

- Содержит только разметку интерфейса эффекта.
- Для элементов управления используются class или data-атрибуты, а не id.
- Пример:
  ```html
  <div class="delay-effect">
    <label>
      Time: <input data-fx-delay_time type="range" min="16" max="2500" step="1">
    </label>
  </div>
  ```

### Результат

- Каждый эффект — отдельные HTML и JS-файлы.
- Вся логика работы с UI и аудио-нодами инкапсулирована в классе эффекта.
- Стандартизированный интерфейс через AbstractEffectNode облегчает интеграцию новых эффектов и работу в будущем EffectChainManager.


Вот подробное пошаговое техническое задание (ТЗ) для создания EffectChainManager.

---

# EffectChainManager

## Цель
Реализовать отдельный модуль (класс) EffectChainManager, который управляет цепочкой аудиоэффектов: добавлением, удалением, перемещением, пересборкой аудио-цепочки и интеграцией с DOM/HTML.

## Шаги реализации

### 1. Создать файл core/EffectChainManager.js
- В этом файле будет реализован класс EffectChainManager.
- Экспортировать класс для использования в других частях приложения.

### 2. Определить структуру данных
- Внутри менеджера хранить массив effectChain, где каждый элемент — объект с:
  - уникальным идентификатором (id)
  - именем эффекта (name)
  - ссылкой на DOM-элемент эффекта (dom)
  - ссылкой на экземпляр аудио-объекта эффекта (audioNode)
  - (опционально) дополнительные параметры

### 3. Реализовать метод addEffect(effectName, index)
- Асинхронно загрузить HTML-файл эффекта через fetch.
- Создать DOM-обёртку для эффекта, вставить в контейнер по нужному индексу.
- Динамически импортировать JS-класс эффекта.
- Создать экземпляр эффекта, передав ему аудиоконтекст и DOM-элемент.
- Добавить объект эффекта в массив effectChain по нужному индексу.
- Пересобрать аудио-цепочку (rebuildAudioChain).
- Вернуть объект эффекта или его id.

### 4. Реализовать метод removeEffect(effectObjOrId)
- Найти эффект в массиве effectChain по объекту или id.
- Вызвать destroy у экземпляра эффекта (если реализовано).
- Удалить DOM-элемент эффекта из контейнера.
- Удалить объект из массива effectChain.
- Пересобрать аудио-цепочку.

### 5. Реализовать метод moveEffect(effectObjOrId, newIndex)
- Найти эффект в массиве effectChain.
- Переместить объект в массиве на новую позицию.
- Переместить DOM-элемент в контейнере на новую позицию.
- Пересобрать аудио-цепочку.

### 6. Реализовать метод rebuildAudioChain()
- Пройти по массиву effectChain и соединить аудио-ноды друг с другом в правильном порядке:
  - Первый эффект коннектится к источнику (или предыдущему элементу).
  - Каждый следующий — к предыдущему.
  - Последний — к выходу (например, AudioContext.destination).
- Отключить старые соединения перед пересборкой.

### 7. Реализовать вспомогательные методы
- getEffectById(id) — получить объект эффекта по id.
- getEffects() — получить текущий массив effectChain.
- clear() — удалить все эффекты из цепочки.

### 8. Интеграция с UI
- В основном скрипте (`script.js`) создать экземпляр EffectChainManager.
- Использовать методы addEffect, 
- В будущем: removeEffect, moveEffect для управления цепочкой из UI (кнопки, drag-and-drop и т.д.).

### 9. Обеспечить универсальность
- Все методы должны работать с любыми эффектами, реализующими стандартный интерфейс (наследники AbstractEffectNode).
- Не использовать жёстко заданные имена параметров или классов.

### Результат

- Гибкий и расширяемый менеджер цепочки эффектов, который:
  - Позволяет добавлять, удалять, перемещать эффекты в любом порядке.
  - Автоматически пересобирает аудио-цепочку при изменениях.
  - Интегрируется с DOM и динамически загружает HTML/JS эффектов.
  - Легко расширяется для новых эффектов и UI-функций.
